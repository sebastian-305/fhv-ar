import * as s from "three";
class p {
  constructor() {
    this.EARTH = 4007501668e-2, this.HALF_EARTH = 2003750834e-2;
  }
  project(e, t) {
    return [this.lonToSphMerc(e), this.latToSphMerc(t)];
  }
  unproject(e) {
    return [this.sphMercToLon(e[0]), this.sphMercToLat(e[1])];
  }
  lonToSphMerc(e) {
    return e / 180 * this.HALF_EARTH;
  }
  latToSphMerc(e) {
    var t = Math.log(Math.tan((90 + e) * Math.PI / 360)) / (Math.PI / 180);
    return t * this.HALF_EARTH / 180;
  }
  sphMercToLon(e) {
    return e / this.HALF_EARTH * 180;
  }
  sphMercToLat(e) {
    var t = e / this.HALF_EARTH * 180;
    return t = 180 / Math.PI * (2 * Math.atan(Math.exp(t * Math.PI / 180)) - Math.PI / 2), t;
  }
  getID() {
    return "epsg:3857";
  }
}
class _ {
  constructor(e, t, i = {}) {
    this._scene = e, this._camera = t, this._proj = new p(), this._eventHandlers = {}, this._lastCoords = null, this._gpsMinDistance = 0, this._gpsMinAccuracy = 100, this._watchPositionId = null, this.setGpsOptions(i), this.initialPosition = null;
  }
  setProjection(e) {
    this._proj = e;
  }
  setGpsOptions(e = {}) {
    e.gpsMinDistance !== void 0 && (this._gpsMinDistance = e.gpsMinDistance), e.gpsMinAccuracy !== void 0 && (this._gpsMinAccuracy = e.gpsMinAccuracy);
  }
  startGps() {
    return this._watchPositionId === null ? (this._watchPositionId = navigator.geolocation.watchPosition(
      (e) => {
        this._gpsReceived(e);
      },
      (e) => {
        this._eventHandlers.gpserror ? this._eventHandlers.gpserror(e.code) : alert(`GPS error: code ${e.code}`);
      },
      {
        enableHighAccuracy: !0
      }
    ), !0) : !1;
  }
  stopGps() {
    return this._watchPositionId !== null ? (navigator.geolocation.clearWatch(this._watchPositionId), this._watchPositionId = null, !0) : !1;
  }
  fakeGps(e, t, i = null, n = 0) {
    i !== null && this.setElevation(i), this._gpsReceived({
      coords: {
        longitude: e,
        latitude: t,
        accuracy: n
      }
    });
  }
  lonLatToWorldCoords(e, t) {
    const i = this._proj.project(e, t);
    if (this.initialPosition)
      i[0] -= this.initialPosition[0], i[1] -= this.initialPosition[1];
    else
      throw "No initial position determined";
    return [i[0], -i[1]];
  }
  add(e, t, i, n, a = {}) {
    e.properties = a, this.setWorldPosition(e, t, i, n), this._scene.add(e);
  }
  setWorldPosition(e, t, i, n) {
    const a = this.lonLatToWorldCoords(t, i);
    n !== void 0 && (e.position.y = n), [e.position.x, e.position.z] = a;
  }
  setElevation(e) {
    this._camera.position.y = e;
  }
  on(e, t) {
    this._eventHandlers[e] = t;
  }
  setWorldOrigin(e, t) {
    this.initialPosition = this._proj.project(e, t);
  }
  _gpsReceived(e) {
    let t = Number.MAX_VALUE;
    e.coords.accuracy <= this._gpsMinAccuracy && (this._lastCoords === null ? this._lastCoords = {
      latitude: e.coords.latitude,
      longitude: e.coords.longitude
    } : t = this._haversineDist(this._lastCoords, e.coords), t >= this._gpsMinDistance && (this._lastCoords.longitude = e.coords.longitude, this._lastCoords.latitude = e.coords.latitude, this.initialPosition || this.setWorldOrigin(
      e.coords.longitude,
      e.coords.latitude
    ), this.setWorldPosition(
      this._camera,
      e.coords.longitude,
      e.coords.latitude
    ), this._eventHandlers.gpsupdate && this._eventHandlers.gpsupdate(e, t)));
  }
  /**
   * Calculate haversine distance between two lat/lon pairs.
   *
   * Taken from original A-Frame AR.js location-based components
   */
  _haversineDist(e, t) {
    const i = s.MathUtils.degToRad(t.longitude - e.longitude), n = s.MathUtils.degToRad(t.latitude - e.latitude), a = Math.sin(n / 2) * Math.sin(n / 2) + Math.cos(s.MathUtils.degToRad(e.latitude)) * Math.cos(s.MathUtils.degToRad(t.latitude)) * (Math.sin(i / 2) * Math.sin(i / 2));
    return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) * 6371e3;
  }
}
class E {
  constructor(e, t, i) {
    this.renderer = e, this.renderer.autoClear = !1, this.sceneWebcam = new s.Scene();
    let n;
    t === void 0 ? (n = document.createElement("video"), n.setAttribute("autoplay", !0), n.setAttribute("playsinline", !0), n.style.display = "none", document.body.appendChild(n)) : n = document.querySelector(t), this.geom = new s.PlaneGeometry(), this.texture = new s.VideoTexture(n), this.material = new s.MeshBasicMaterial({ map: this.texture });
    const a = new s.Mesh(this.geom, this.material);
    if (this.sceneWebcam.add(a), this.cameraWebcam = new s.OrthographicCamera(
      -0.5,
      0.5,
      0.5,
      -0.5,
      0,
      10
    ), navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      const r = {
        video: {
          width: (i == null ? void 0 : i.width) || 1280,
          height: (i == null ? void 0 : i.height) || 720,
          facingMode: "environment"
        }
      };
      navigator.mediaDevices.getUserMedia(r).then((c) => {
        console.log("using the webcam successfully..."), n.srcObject = c, n.play();
      }).catch((c) => {
        setTimeout(() => {
          this.createErrorPopup(
            `Webcam Error
Name: ` + c.name + `
Message: ` + c.message
          );
        }, 1e3);
      });
    } else
      setTimeout(() => {
        this.createErrorPopup("sorry - media devices API not supported");
      }, 1e3);
  }
  update() {
    this.renderer.clear(), this.renderer.render(this.sceneWebcam, this.cameraWebcam), this.renderer.clearDepth();
  }
  dispose() {
    this.material.dispose(), this.texture.dispose(), this.geom.dispose();
  }
  createErrorPopup(e) {
    if (!document.getElementById("error-popup")) {
      var t = document.createElement("div");
      t.innerHTML = e, t.setAttribute("id", "error-popup"), document.body.appendChild(t);
    }
  }
}
const v = new s.Vector3(0, 0, 1), m = new s.Euler(), M = new s.Quaternion(), f = new s.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)), w = { type: "change" };
class P extends s.EventDispatcher {
  constructor(e) {
    super(), window.isSecureContext === !1 && console.error("THREE.DeviceOrientationControls: DeviceOrientationEvent is only available in secure contexts (https)");
    const t = this, i = 1e-6, n = new s.Quaternion();
    this.object = e, this.object.rotation.reorder("YXZ"), this.enabled = !0, this.deviceOrientation = {}, this.screenOrientation = 0, this.alphaOffset = 0, this.deviceOrientationEventName = "ondeviceorientationabsolute" in window ? "deviceorientationabsolute" : "deviceorientation";
    const a = function(o) {
      t.deviceOrientation = o;
    }, r = function() {
      t.screenOrientation = window.orientation || 0;
    }, c = function(o, l, h, u, g) {
      m.set(h, l, -u, "YXZ"), o.setFromEuler(m), o.multiply(f), o.multiply(M.setFromAxisAngle(v, -g));
    };
    this.connect = function() {
      r(), window.DeviceOrientationEvent !== void 0 && typeof window.DeviceOrientationEvent.requestPermission == "function" ? window.DeviceOrientationEvent.requestPermission().then(function(o) {
        o == "granted" && (window.addEventListener("orientationchange", r), window.addEventListener(t.deviceOrientationEventName, a));
      }).catch(function(o) {
        console.error("THREE.DeviceOrientationControls: Unable to use DeviceOrientation API:", o);
      }) : (window.addEventListener("orientationchange", r), window.addEventListener(t.deviceOrientationEventName, a)), t.enabled = !0;
    }, this.disconnect = function() {
      window.removeEventListener("orientationchange", r), window.removeEventListener(t.deviceOrientationEventName, a), t.enabled = !1;
    }, this.update = function() {
      if (t.enabled === !1) return;
      const o = t.deviceOrientation;
      if (o) {
        const l = o.alpha ? s.MathUtils.degToRad(o.alpha) + t.alphaOffset : 0, h = o.beta ? s.MathUtils.degToRad(o.beta) : 0, u = o.gamma ? s.MathUtils.degToRad(o.gamma) : 0, g = t.screenOrientation ? s.MathUtils.degToRad(t.screenOrientation) : 0;
        c(t.object.quaternion, l, h, u, g), 8 * (1 - n.dot(t.object.quaternion)) > i && (n.copy(t.object.quaternion), t.dispatchEvent(w));
      }
    }, this.dispose = function() {
      t.disconnect();
    }, this.connect();
  }
}
class y {
  constructor(e) {
    this.raycaster = new s.Raycaster(), this.normalisedMousePosition = new s.Vector2(null, null), e.domElement.addEventListener("click", (t) => {
      this.normalisedMousePosition.set(
        t.clientX / e.domElement.clientWidth * 2 - 1,
        -(t.clientY / e.domElement.clientHeight * 2) + 1
      );
    });
  }
  raycast(e, t) {
    if (this.normalisedMousePosition.x !== null && this.normalisedMousePosition.y !== null) {
      this.raycaster.setFromCamera(this.normalisedMousePosition, e);
      const i = this.raycaster.intersectObjects(t.children, !1);
      return this.normalisedMousePosition.set(null, null), i;
    }
    return [];
  }
}
export {
  y as ClickHandler,
  P as DeviceOrientationControls,
  _ as LocationBased,
  E as WebcamRenderer
};
